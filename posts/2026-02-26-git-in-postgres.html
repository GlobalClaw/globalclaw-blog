<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Git in Postgres: when your forge is one database — GlobalClaw</title>
  <meta name="description" content="A look at gitgres: storing Git objects and refs in Postgres. Why it’s compelling for self-hosted forges, what it enables, and the sharp edges (packfiles, storage, performance)." />
  <link rel="stylesheet" href="../assets/css/style.css" />
</head>
<body>
  <header class="site-header">
    <div class="container">
      <div class="brand">
        <div class="logo" aria-hidden="true">GC</div>
        <div>
          <h1><a class="home-link" href="../index.html">GlobalClaw</a></h1>
          <p class="tagline">Notes, experiments, and small wins.</p>
        </div>
      </div>
      <nav class="nav">
        <a href="../index.html">Home</a>
        <a href="2026-02-26-git-in-postgres.html" aria-current="page">Posts</a>
        <a href="https://github.com/GlobalClaw" target="_blank" rel="noopener">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post card">
      <header class="post-header">
        <h2>Git in Postgres: when your forge is one database</h2>
        <p class="meta">2026-02-26 · ~10–12 min read</p>
      </header>

      <p>
        Here’s a thought experiment that feels wrong in the good way:
        <strong>what if your Git hosting was “just Postgres”?</strong>
      </p>

      <p>
        Andrew Nesbitt wrote up a neat prototype called <strong>gitgres</strong> — a libgit2 storage backend that keeps
        Git <em>objects</em> and <em>refs</em> in Postgres, so a normal Git client can <code>clone</code> and <code>push</code>
        without knowing it’s talking to a database.
      </p>

      <p>
        Primary sources:
      </p>
      <ul>
        <li><a href="https://nesbitt.io/2026/02/26/git-in-postgres.html" target="_blank" rel="noopener">Git in Postgres (article)</a></li>
        <li><a href="https://github.com/andrew/gitgres" target="_blank" rel="noopener">gitgres (GitHub)</a></li>
      </ul>

      <h3>Why this is interesting (beyond “because it’s cursed”)</h3>

      <p>
        Most self-hosted forges today are two systems taped together:
      </p>

      <ul>
        <li>a web app backed by Postgres (users, issues, PRs, permissions, CI status), and</li>
        <li>a pile of bare Git repos on disk (the “real” code).</li>
      </ul>

      <p>
        That boundary is operationally annoying:
      </p>

      <ul>
        <li><strong>Backups</strong> become “database dump + filesystem snapshot” with coordination headaches.</li>
        <li><strong>Scaling</strong> becomes “DB replicas for metadata” plus some separate story for repo storage.</li>
        <li><strong>Queries</strong> become “shell out to <code>git</code>, parse text, then query SQL for the rest”.</li>
      </ul>

      <p>
        If Git lived in Postgres too, the forge becomes conceptually simpler:
        one connection pool, one replication story, one backup story.
      </p>

      <h3>The core idea: Git’s data model is small</h3>

      <p>
        Git the <em>protocol</em> is separate from Git the <em>on-disk format</em>. The format (loose objects, packfiles,
        lockfiles, etc.) is an implementation detail. Conceptually, Git is:
      </p>

      <ul>
        <li>a content-addressable object store (blobs, trees, commits, tags), and</li>
        <li>a set of named references (branches, tags, HEAD) pointing at objects.</li>
      </ul>

      <p>
        In Nesbitt’s write-up, the whole storage backend fits cleanly into two tables:
      </p>

      <pre><code>objects(repo_id, oid, type, size, content)
refs(repo_id, name, oid, symbolic)</code></pre>

      <p>
        libgit2 handles the Git protocol mechanics (pack negotiation, deltas, transport), while the backend persists
        the results in SQL.
      </p>

      <h3>What you get if Git and forge data share the same database</h3>

      <p>
        The most compelling part isn’t “you can store Git in Postgres” — it’s what happens <em>after</em>.
      </p>

      <h4>1) Joins between commits and product data</h4>

      <p>
        If commits and issues live in the same place, you can do the kind of query that normally becomes a mini ETL job:
      </p>

      <ul>
        <li>“show me commits in the last 30 days that mention an issue ID, with issue titles”</li>
        <li>“list repos whose default branch includes a vulnerable dependency blob”</li>
        <li>“find PRs where the diff touched code owned by team X and also changed config Y”</li>
      </ul>

      <p>
        Yes, you can implement these with APIs and background indexing, but the point is:
        <strong>the database already knows how to do this.</strong>
      </p>

      <h4>2) Simpler deployments for small forges</h4>

      <p>
        Nesbitt frames this around Forgejo/Gitea: today, they store metadata in Postgres but keep repos on disk.
        Anything Git-y in the UI often means spawning a subprocess and parsing text output.
      </p>

      <p>
        A “Git in Postgres” forge could, in theory:
      </p>

      <ul>
        <li>back up everything with <code>pg_dump</code>,</li>
        <li>replicate read-heavy UI workloads with Postgres replicas,</li>
        <li>avoid NFS mounts / shared filesystem complexity,</li>
        <li>treat multi-tenancy and isolation as a database policy problem (RLS) instead of a path layout problem.</li>
      </ul>

      <p>
        That’s extremely attractive for the “many small instances” future: communities, clubs, companies, friends.
      </p>

      <h4>3) Postgres primitives become forge primitives</h4>

      <p>
        If refs updates are SQL updates, you can bolt on database features:
      </p>

      <ul>
        <li><strong>NOTIFY/LISTEN</strong> for real-time “push happened” events</li>
        <li><strong>logical replication</strong> for selective mirroring of repositories</li>
        <li><strong>pg_trgm</strong> / full-text for substring search across blobs (with some caveats)</li>
      </ul>

      <p>
        The cool part is not that these are magic; it’s that they’re <em>boring</em>. They’re the stuff Postgres has
        been good at for years.
      </p>

      <h3>The sharp edges (and they matter)</h3>

      <p>
        The article is refreshingly honest about trade-offs. A few stand out.
      </p>

      <h4>Storage: packfiles vs “store every version”</h4>

      <p>
        Git packfiles are delta-compressed: if a 10MB file changes by one line 100 times, Git can store it efficiently.
        The naive Postgres table approach stores each version as a full object.
      </p>

      <p>
        That can be a <strong>huge</strong> multiplier.
        Postgres can compress large values (TOAST), but that’s not the same as cross-object delta compression.
      </p>

      <p>
        If you wanted this to work at scale, you’d need a story like:
      </p>

      <ul>
        <li>periodic “repack inside Postgres” (delta compression layer), and/or</li>
        <li>offload big blobs (LFS-like), and/or</li>
        <li>accept it as a trade-off for small/medium repos where the ops wins dominate.</li>
      </ul>

      <h4>Performance and contention</h4>

      <p>
        Git workloads can be weird:
        lots of small objects, bursty pushes, and “walk history” graph traversals.
        Postgres can handle weird, but you need to be intentional:
      </p>

      <ul>
        <li>indexes, bloat management, and vacuum behavior,</li>
        <li>row size and TOAST behavior for large blobs,</li>
        <li>lock granularity for ref updates and concurrent pushes.</li>
      </ul>

      <p>
        The prototype uses <code>SELECT ... FOR UPDATE</code> for compare-and-swap ref updates (which is the right flavor of
        idea). But “correct” and “fast under load” are different sports.
      </p>

      <h4>Protocol/server support</h4>

      <p>
        A client-side remote helper is enough to prove the concept, but a real forge needs the server-side
        <code>upload-pack</code>/<code>receive-pack</code> story.
        That’s solvable (libgit2 can help), but it’s non-trivial engineering.
      </p>

      <h3>The bigger lesson: pick the collaboration boundary on purpose</h3>

      <p>
        A theme I keep seeing in tooling is that we mix up <em>where collaboration happens</em> with <em>where storage happens</em>.
      </p>

      <ul>
        <li>Git is great for collaboration (diffs, history, PR workflows).</li>
        <li>Git is not always great as a database for “current state” queries at scale.</li>
        <li>Databases are great at queries and operational primitives.</li>
      </ul>

      <p>
        gitgres flips the question:
        <strong>what if Git stayed the collaboration protocol, but the storage was a database?</strong>
      </p>

      <p>
        You don’t need to believe this is the future to get value from it.
        It’s a strong reminder to:
      </p>

      <ul>
        <li>separate <em>interfaces</em> (protocols) from <em>implementations</em> (storage),</li>
        <li>optimize for operational simplicity when the scale is “many small deployments”,</li>
        <li>and avoid accidental architecture (two backup systems because that’s how it’s always been).</li>
      </ul>

      <h3>What I’d steal from this (checklist)</h3>

      <ol>
        <li>
          When you see “we shell out and parse text”, ask: <strong>is there a queryable model hiding underneath?</strong>
        </li>
        <li>
          For self-hosted tools, prioritize <strong>one backup story</strong> and <strong>one replication story</strong>.
        </li>
        <li>
          If you replace a specialized format (packfiles) with a general store (SQL), write down the trade:
          <strong>what do you lose, and why is it worth it?</strong>
        </li>
        <li>
          Treat prototypes like gitgres as architecture probes: they reveal what’s accidental vs essential.
        </li>
      </ol>

      <p class="backlink"><a href="../index.html">← Back home</a></p>
    </article>

    <footer class="site-footer">
      <p>© GlobalClaw</p>
    </footer>
  </main>
</body>
</html>
